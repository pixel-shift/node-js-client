/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as moment from "moment";


/**
 * @class
 * Initializes a new instance of the TransformUnit class.
 * @constructor
 * @member {string} kind Polymorphic Discriminator
 */
export interface TransformUnit {
  kind: string;
}

/**
 * @class
 * Initializes a new instance of the TransformGraph class.
 * @constructor
 * A description of steps for processing images from source to destination. Can
 * be branched by using the "outputs"
 * property to allow for multiple transformations on a single source image.
 *
 * @member {array} transforms A list of transforms that run one after another,
 * piping content from one transform to the next
 * @member {array} [outputs] A list of output transform graphs, each one
 * receiving the output of the last transform in the "transforms"
 * collection
 */
export interface TransformGraph {
  transforms: TransformUnit[];
  outputs?: TransformGraph[];
}

/**
 * @class
 * Initializes a new instance of the Batch class.
 * @constructor
 * Container for submitting batches of transform graphs
 *
 * @member {array} items Collection of transform graphs for processing. Each
 * item represents a single billable operation.
 */
export interface Batch {
  items: TransformGraph[];
}

/**
 * @class
 * Initializes a new instance of the BatchStartReportResponse class.
 * @constructor
 * Report indicating if a batch has been successfully submitted, providing an
 * endpoint to monitor batch progress
 *
 * @member {boolean} [success] indicates that that batch was successfully
 * submitted
 * @member {string} [error] if the batch was not submitted successfully, there
 * will be an error message
 * @member {uuid} [id] the id of the batch
 * @member {string} [statusEndpoint] if the batch was submitted successfully,
 * the url of an endpoint for checking batch progress
 * @member {array} [operationIds] if the batch was submitted successfully, a
 * list of the ids of submitted operations,
 * in the same order as the submitted operations
 */
export interface BatchStartReportResponse {
  success?: boolean;
  error?: string;
  id?: string;
  statusEndpoint?: string;
  operationIds?: string[];
}

/**
 * @class
 * Initializes a new instance of the BatchLinkResponse class.
 * @constructor
 * A summary with a url for a status report on a specific batch id
 *
 * @member {uuid} [batchId] the id of the batch
 * @member {date} [created] the time that the batch was submitted
 * @member {string} [url] a url for a status report on the batch
 */
export interface BatchLinkResponse {
  batchId?: string;
  created?: Date;
  url?: string;
}

/**
 * @class
 * Initializes a new instance of the AllBatchesPageResponse class.
 * @constructor
 * a model for a long list of batches with potential future paging support
 *
 * @member {number} [pageIndex] the current page (0 based)
 * @member {number} [totalPages] the total number of pages
 * @member {array} [batches] a list of batches with urls for individual batch
 * reports
 */
export interface AllBatchesPageResponse {
  pageIndex?: number;
  totalPages?: number;
  batches?: BatchLinkResponse[];
}

/**
 * @class
 * Initializes a new instance of the OperationInfoResponse class.
 * @constructor
 * A report of the id and an endpoint for checking the status of an operation
 *
 * @member {uuid} [id] the id of the operation
 * @member {string} [url] an endpoint for a summary of the operation
 */
export interface OperationInfoResponse {
  id?: string;
  url?: string;
}

/**
 * @class
 * Initializes a new instance of the BatchReportResponse class.
 * @constructor
 * A summary of batch compute time and pending, failed and completed operations
 *
 * @member {number} [aggregateComputeTime] the total amount of CPU time spent
 * on this batch. if there are pending operations,
 * then this figure is not final
 * @member {string} [status] True if all operations in batch have been
 * processed. Possible values include: 'pending', 'finished'
 * @member {date} [created] when the batch was submitted
 * @member {array} [pending] list of id/summary endpoint for operations that
 * are still pending
 * @member {array} [completed] list of id/summary endpoint for operations that
 * are completed
 * @member {array} [failed] list of id/summary endpoint for operations that
 * have failed
 */
export interface BatchReportResponse {
  aggregateComputeTime?: number;
  status?: string;
  created?: Date;
  pending?: OperationInfoResponse[];
  completed?: OperationInfoResponse[];
  failed?: OperationInfoResponse[];
}

/**
 * @class
 * Initializes a new instance of the OperationStatusReportResponse class.
 * @constructor
 * a processing summary of an operation
 *
 * @member {date} [created] when the operation was created
 * @member {string} [status] the current status of the operation. Possible
 * values include: 'pending', 'failed', 'success'
 * @member {string} [error] if the operation has a status of "failed", this
 * will contain an error message
 * @member {number} [elapsedMicroseconds] time taken for an operation
 * @member {string} [operationDescriptionUrl] an endpoint that provides the
 * original operation parameters
 */
export interface OperationStatusReportResponse {
  created?: Date;
  status?: string;
  error?: string;
  elapsedMicroseconds?: number;
  operationDescriptionUrl?: string;
}

/**
 * @class
 * Initializes a new instance of the TransformGraphMetadataEnvelope class.
 * @constructor
 * A wrapped for RawTransformGraph instances, containing operation-specific
 * metadata
 *
 * @member {object} [graph] The transform graph that represents the operation
 * @member {array} [graph.transforms] A list of transforms that run one after
 * another, piping content from one transform to the next
 * @member {array} [graph.outputs] A list of output transform graphs, each one
 * receiving the output of the last transform in the "transforms"
 * collection
 * @member {uuid} [operationId] The operation id of this operation
 * @member {uuid} [batchId] The batch id of the batch containing this operation
 * @member {uuid} [accountId] The account id of the account that will be/was
 * charged for this operation
 * @member {number} [ownerId] The user id of the user that submitted this batch
 */
export interface TransformGraphMetadataEnvelope {
  graph?: TransformGraph;
  operationId?: string;
  batchId?: string;
  accountId?: string;
  ownerId?: number;
}

/**
 * @class
 * Initializes a new instance of the StorageSourceS3 class.
 * @constructor
 * Describes the source location of a graph. Must appear only once at the front
 * of transform sequences (or as the
 * head element in the conceptual transform graph) and be immediately preceded
 * by an ImageFormatTransformPipe
 * such as ImageFormat_Jpeg/ImageFormat_Tiff/ImageFormat_Png/ImageFormat_Webp
 *
 * @member {string} sourceKey Source key name
 * @member {string} sourceBucket Source bucket name
 */
export interface StorageSourceS3 extends TransformUnit {
  sourceKey: string;
  sourceBucket: string;
}

/**
 * @class
 * Initializes a new instance of the StorageSinkS3 class.
 * @constructor
 * Describes the destination location of a branch of the graph. Must appear at
 * the end of transform sequences (or
 * as a leaf in the conceptual transform graph) and be immediately preceded by
 * an ImageFormatTransformPipe
 * (type:"Image.OutputFormat")
 *
 * @member {string} destinationKey Destination key name
 * @member {string} destinationBucket Destination bucket name
 * @member {boolean} [allowOverwrite] Allow overwrite of destination. Default
 * value: false .
 */
export interface StorageSinkS3 extends TransformUnit {
  destinationKey: string;
  destinationBucket: string;
  allowOverwrite?: boolean;
}

/**
 * @class
 * Initializes a new instance of the ImageGrayscale class.
 * @constructor
 * Converts source to grayscale.
 *
 */
export interface ImageGrayscale extends TransformUnit {
}

/**
 * @class
 * Initializes a new instance of the Bounds class.
 * @constructor
 * Object used to represent border thickness.
 *
 * @member {number} top Width of top border.
 * @member {number} left Width of left border.
 * @member {number} bottom Width of bottom border.
 * @member {number} right Width of right border
 */
export interface Bounds {
  top: number;
  left: number;
  bottom: number;
  right: number;
}

/**
 * @class
 * Initializes a new instance of the Color class.
 * @constructor
 * Representation of an RGB color.
 *
 * @member {number} r The red component.
 * @member {number} g The green component.
 * @member {number} b The blue component.
 */
export interface Color {
  r: number;
  g: number;
  b: number;
}

/**
 * @class
 * Initializes a new instance of the ImageExtend class.
 * @constructor
 * Creates a border of specified width and color around the source.
 *
 * @member {object} extend The width of the border
 * @member {number} [extend.top] Width of top border.
 * @member {number} [extend.left] Width of left border.
 * @member {number} [extend.bottom] Width of bottom border.
 * @member {number} [extend.right] Width of right border
 * @member {object} background The color of the border
 * @member {number} [background.r] The red component.
 * @member {number} [background.g] The green component.
 * @member {number} [background.b] The blue component.
 */
export interface ImageExtend extends TransformUnit {
  extend: Bounds;
  background: Color;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeAutoCrop class.
 * @constructor
 * Resize image with touch-from-outside semantics with automatic positioning of
 * crop area using two different
 * strategies
 *
 * @member {number} width Output width
 * @member {number} height Output height
 * @member {string} [strategy] Strategy used for positioning crop area.
 * Possible values include: 'attention', 'entropy'. Default value: 'attention'
 * .
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeAutoCrop extends TransformUnit {
  width: number;
  height: number;
  strategy?: string;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeCrop class.
 * @constructor
 * Resize image with touch-from-outside semantics with manual positioning of
 * crop area via the gravity parameter.
 *
 * @member {number} width Output width
 * @member {number} height Output height
 * @member {string} [gravity] Position of crop area by gravity. Possible values
 * include: 'center', 'centre', 'north', 'northeast', 'east', 'southeast',
 * 'south', 'southwest', 'west', 'northwest'. Default value: 'center' .
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeCrop extends TransformUnit {
  width: number;
  height: number;
  gravity?: string;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeMax class.
 * @constructor
 * Resize image with touch-from-inside semantics where width and height
 * represent maximums. e.g. the image will be
 * no larger that the bounding-box.
 * Aspect ratio is preserved, so image will be smaller than or equal to the
 * bounding box in one dimension, and
 * exactly fit the other dimension
 *
 * @member {number} width Maximum width
 * @member {number} height Maximum height
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeMax extends TransformUnit {
  width: number;
  height: number;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeMin class.
 * @constructor
 * Resize image with touch-from-outside semantics where width and height
 * represent minimums. e.g. the image will
 * be no smaller that the bounding-box.
 * Aspect ratio is preserved, so image will be larger than or equal to the
 * bounding box in one dimension, and
 * exactly fit the other dimension
 *
 * @member {number} width Minimum width
 * @member {number} height Minimum height
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeMin extends TransformUnit {
  width: number;
  height: number;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeToHeight class.
 * @constructor
 * Resize the image to a specific height. Width will depend on aspect ratio of
 * image.
 *
 * @member {number} height Output height
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeToHeight extends TransformUnit {
  height: number;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageResizeToWidth class.
 * @constructor
 * Resize the image to a specific width. Height will depend on aspect ratio of
 * image.
 *
 * @member {number} width
 * @member {string} [resizeKernel] The resampling algorithm used for resizing.
 * Possible values include: 'lanczos3', 'lanczos2', 'cubic', 'nearest'. Default
 * value: 'lanczos3' .
 */
export interface ImageResizeToWidth extends TransformUnit {
  width: number;
  resizeKernel?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageTint class.
 * @constructor
 * Change image colors to tinted monochrome
 *
 * @member {object} tint The tint color
 * @member {number} [tint.r] The red component.
 * @member {number} [tint.g] The green component.
 * @member {number} [tint.b] The blue component.
 */
export interface ImageTint extends TransformUnit {
  tint: Color;
}

/**
 * @class
 * Initializes a new instance of the ImageFormatJpeg class.
 * @constructor
 * Output to Jpeg
 *
 * @member {number} [quality] Jpeg quality. Default value: 80 .
 * @member {boolean} [progressive] Create progressive/interlace scan jpeg.
 * Default value: false .
 */
export interface ImageFormatJpeg extends TransformUnit {
  quality?: number;
  progressive?: boolean;
}

/**
 * @class
 * Initializes a new instance of the ImageFormatPng class.
 * @constructor
 * Output to Png
 *
 * @member {number} [compressionLevel] Png compression level. Default value: 9
 * .
 * @member {boolean} [progressive] Create progressive/interlace scan png.
 * Default value: false .
 * @member {boolean} [adaptiveFiltering] Use adaptive row filtering. Default
 * value: false .
 */
export interface ImageFormatPng extends TransformUnit {
  compressionLevel?: number;
  progressive?: boolean;
  adaptiveFiltering?: boolean;
}

/**
 * @class
 * Initializes a new instance of the ImageFormatTiff class.
 * @constructor
 * Output to Tiff
 *
 * @member {number} [quality] Tiff compression level. Default value: 80 .
 * @member {string} [compression] Type of compression used in Tiff output.
 * Possible values include: 'jpeg', 'deflate', 'lzw', 'ccittfax4'. Default
 * value: 'jpeg' .
 * @member {string} [predictor] Tiff compression predictor. Possible values
 * include: 'horizontal', 'float', 'none'. Default value: 'horizontal' .
 */
export interface ImageFormatTiff extends TransformUnit {
  quality?: number;
  compression?: string;
  predictor?: string;
}

/**
 * @class
 * Initializes a new instance of the ImageFormatWebp class.
 * @constructor
 * Output to Webp
 *
 * @member {number} [quality] Webp compression level. Default value: 80 .
 */
export interface ImageFormatWebp extends TransformUnit {
  quality?: number;
}

/**
 * @class
 * Initializes a new instance of the UnitUnknown class.
 * @constructor
 * Target type for TransformUnits that are unrecognized at the current schema
 * level
 *
 */
export interface UnitUnknown extends TransformUnit {
}
